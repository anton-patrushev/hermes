/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// @generated by Hermes rustgen
// DO NOT EDIT

use hermes::parser::*;
use super::convert::*;
use crate::ast;

pub unsafe fn cvt_node_ptr(cvt: &mut Converter, n: NodePtr) -> ast::NodePtr {
    let nr = n.as_ref();
    let range = ast::SourceRange {
        file: cvt.file_id,
        start: cvt.cvt_smloc(nr.source_range.start),
        end: ast::SourceLoc::invalid(),
    };

    let res = match nr.kind {
        NodeKind::Empty => {
          cvt.ast_context.alloc(
            ast::Node::Empty(ast::Empty {
                range,
            }),
          )
        }
        NodeKind::Metadata => {
          cvt.ast_context.alloc(
            ast::Node::Metadata(ast::Metadata {
                range,
            }),
          )
        }
        NodeKind::Program => {
          let body = cvt_node_list(cvt, hermes_get_Program_body(n));
          cvt.ast_context.alloc(
            ast::Node::Program(ast::Program {
                range,
                    body,
            }),
          )
        }
        NodeKind::FunctionExpression => {
          let id = cvt_node_ptr_opt(cvt, hermes_get_FunctionExpression_id(n));
          let params = cvt_node_list(cvt, hermes_get_FunctionExpression_params(n));
          let body = cvt_node_ptr(cvt, hermes_get_FunctionExpression_body(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_FunctionExpression_typeParameters(n));
          let return_type = cvt_node_ptr_opt(cvt, hermes_get_FunctionExpression_returnType(n));
          let predicate = cvt_node_ptr_opt(cvt, hermes_get_FunctionExpression_predicate(n));
          let generator = hermes_get_FunctionExpression_generator(n);
          let is_async = hermes_get_FunctionExpression_async(n);
          cvt.ast_context.alloc(
            ast::Node::FunctionExpression(ast::FunctionExpression {
                range,
                    id,
                    params,
                    body,
                    type_parameters,
                    return_type,
                    predicate,
                    generator,
                    is_async,
            }),
          )
        }
        NodeKind::ArrowFunctionExpression => {
          let id = cvt_node_ptr_opt(cvt, hermes_get_ArrowFunctionExpression_id(n));
          let params = cvt_node_list(cvt, hermes_get_ArrowFunctionExpression_params(n));
          let body = cvt_node_ptr(cvt, hermes_get_ArrowFunctionExpression_body(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_ArrowFunctionExpression_typeParameters(n));
          let return_type = cvt_node_ptr_opt(cvt, hermes_get_ArrowFunctionExpression_returnType(n));
          let predicate = cvt_node_ptr_opt(cvt, hermes_get_ArrowFunctionExpression_predicate(n));
          let expression = hermes_get_ArrowFunctionExpression_expression(n);
          let is_async = hermes_get_ArrowFunctionExpression_async(n);
          cvt.ast_context.alloc(
            ast::Node::ArrowFunctionExpression(ast::ArrowFunctionExpression {
                range,
                    id,
                    params,
                    body,
                    type_parameters,
                    return_type,
                    predicate,
                    expression,
                    is_async,
            }),
          )
        }
        NodeKind::FunctionDeclaration => {
          let id = cvt_node_ptr_opt(cvt, hermes_get_FunctionDeclaration_id(n));
          let params = cvt_node_list(cvt, hermes_get_FunctionDeclaration_params(n));
          let body = cvt_node_ptr(cvt, hermes_get_FunctionDeclaration_body(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_FunctionDeclaration_typeParameters(n));
          let return_type = cvt_node_ptr_opt(cvt, hermes_get_FunctionDeclaration_returnType(n));
          let predicate = cvt_node_ptr_opt(cvt, hermes_get_FunctionDeclaration_predicate(n));
          let generator = hermes_get_FunctionDeclaration_generator(n);
          let is_async = hermes_get_FunctionDeclaration_async(n);
          cvt.ast_context.alloc(
            ast::Node::FunctionDeclaration(ast::FunctionDeclaration {
                range,
                    id,
                    params,
                    body,
                    type_parameters,
                    return_type,
                    predicate,
                    generator,
                    is_async,
            }),
          )
        }
        NodeKind::WhileStatement => {
          let body = cvt_node_ptr(cvt, hermes_get_WhileStatement_body(n));
          let test = cvt_node_ptr(cvt, hermes_get_WhileStatement_test(n));
          cvt.ast_context.alloc(
            ast::Node::WhileStatement(ast::WhileStatement {
                range,
                    body,
                    test,
            }),
          )
        }
        NodeKind::DoWhileStatement => {
          let body = cvt_node_ptr(cvt, hermes_get_DoWhileStatement_body(n));
          let test = cvt_node_ptr(cvt, hermes_get_DoWhileStatement_test(n));
          cvt.ast_context.alloc(
            ast::Node::DoWhileStatement(ast::DoWhileStatement {
                range,
                    body,
                    test,
            }),
          )
        }
        NodeKind::ForInStatement => {
          let left = cvt_node_ptr(cvt, hermes_get_ForInStatement_left(n));
          let right = cvt_node_ptr(cvt, hermes_get_ForInStatement_right(n));
          let body = cvt_node_ptr(cvt, hermes_get_ForInStatement_body(n));
          cvt.ast_context.alloc(
            ast::Node::ForInStatement(ast::ForInStatement {
                range,
                    left,
                    right,
                    body,
            }),
          )
        }
        NodeKind::ForOfStatement => {
          let left = cvt_node_ptr(cvt, hermes_get_ForOfStatement_left(n));
          let right = cvt_node_ptr(cvt, hermes_get_ForOfStatement_right(n));
          let body = cvt_node_ptr(cvt, hermes_get_ForOfStatement_body(n));
          let is_await = hermes_get_ForOfStatement_await(n);
          cvt.ast_context.alloc(
            ast::Node::ForOfStatement(ast::ForOfStatement {
                range,
                    left,
                    right,
                    body,
                    is_await,
            }),
          )
        }
        NodeKind::ForStatement => {
          let init = cvt_node_ptr_opt(cvt, hermes_get_ForStatement_init(n));
          let test = cvt_node_ptr_opt(cvt, hermes_get_ForStatement_test(n));
          let update = cvt_node_ptr_opt(cvt, hermes_get_ForStatement_update(n));
          let body = cvt_node_ptr(cvt, hermes_get_ForStatement_body(n));
          cvt.ast_context.alloc(
            ast::Node::ForStatement(ast::ForStatement {
                range,
                    init,
                    test,
                    update,
                    body,
            }),
          )
        }
        NodeKind::DebuggerStatement => {
          cvt.ast_context.alloc(
            ast::Node::DebuggerStatement(ast::DebuggerStatement {
                range,
            }),
          )
        }
        NodeKind::EmptyStatement => {
          cvt.ast_context.alloc(
            ast::Node::EmptyStatement(ast::EmptyStatement {
                range,
            }),
          )
        }
        NodeKind::BlockStatement => {
          let body = cvt_node_list(cvt, hermes_get_BlockStatement_body(n));
          cvt.ast_context.alloc(
            ast::Node::BlockStatement(ast::BlockStatement {
                range,
                    body,
            }),
          )
        }
        NodeKind::BreakStatement => {
          let label = cvt_node_ptr_opt(cvt, hermes_get_BreakStatement_label(n));
          cvt.ast_context.alloc(
            ast::Node::BreakStatement(ast::BreakStatement {
                range,
                    label,
            }),
          )
        }
        NodeKind::ContinueStatement => {
          let label = cvt_node_ptr_opt(cvt, hermes_get_ContinueStatement_label(n));
          cvt.ast_context.alloc(
            ast::Node::ContinueStatement(ast::ContinueStatement {
                range,
                    label,
            }),
          )
        }
        NodeKind::ThrowStatement => {
          let argument = cvt_node_ptr(cvt, hermes_get_ThrowStatement_argument(n));
          cvt.ast_context.alloc(
            ast::Node::ThrowStatement(ast::ThrowStatement {
                range,
                    argument,
            }),
          )
        }
        NodeKind::ReturnStatement => {
          let argument = cvt_node_ptr_opt(cvt, hermes_get_ReturnStatement_argument(n));
          cvt.ast_context.alloc(
            ast::Node::ReturnStatement(ast::ReturnStatement {
                range,
                    argument,
            }),
          )
        }
        NodeKind::WithStatement => {
          let object = cvt_node_ptr(cvt, hermes_get_WithStatement_object(n));
          let body = cvt_node_ptr(cvt, hermes_get_WithStatement_body(n));
          cvt.ast_context.alloc(
            ast::Node::WithStatement(ast::WithStatement {
                range,
                    object,
                    body,
            }),
          )
        }
        NodeKind::SwitchStatement => {
          let discriminant = cvt_node_ptr(cvt, hermes_get_SwitchStatement_discriminant(n));
          let cases = cvt_node_list(cvt, hermes_get_SwitchStatement_cases(n));
          cvt.ast_context.alloc(
            ast::Node::SwitchStatement(ast::SwitchStatement {
                range,
                    discriminant,
                    cases,
            }),
          )
        }
        NodeKind::LabeledStatement => {
          let label = cvt_node_ptr(cvt, hermes_get_LabeledStatement_label(n));
          let body = cvt_node_ptr(cvt, hermes_get_LabeledStatement_body(n));
          cvt.ast_context.alloc(
            ast::Node::LabeledStatement(ast::LabeledStatement {
                range,
                    label,
                    body,
            }),
          )
        }
        NodeKind::ExpressionStatement => {
          let expression = cvt_node_ptr(cvt, hermes_get_ExpressionStatement_expression(n));
          let directive = cvt_string_opt(hermes_get_ExpressionStatement_directive(n));
          cvt.ast_context.alloc(
            ast::Node::ExpressionStatement(ast::ExpressionStatement {
                range,
                    expression,
                    directive,
            }),
          )
        }
        NodeKind::TryStatement => {
          let block = cvt_node_ptr(cvt, hermes_get_TryStatement_block(n));
          let handler = cvt_node_ptr_opt(cvt, hermes_get_TryStatement_handler(n));
          let finalizer = cvt_node_ptr_opt(cvt, hermes_get_TryStatement_finalizer(n));
          cvt.ast_context.alloc(
            ast::Node::TryStatement(ast::TryStatement {
                range,
                    block,
                    handler,
                    finalizer,
            }),
          )
        }
        NodeKind::IfStatement => {
          let test = cvt_node_ptr(cvt, hermes_get_IfStatement_test(n));
          let consequent = cvt_node_ptr(cvt, hermes_get_IfStatement_consequent(n));
          let alternate = cvt_node_ptr_opt(cvt, hermes_get_IfStatement_alternate(n));
          cvt.ast_context.alloc(
            ast::Node::IfStatement(ast::IfStatement {
                range,
                    test,
                    consequent,
                    alternate,
            }),
          )
        }
        NodeKind::NullLiteral => {
          cvt.ast_context.alloc(
            ast::Node::NullLiteral(ast::NullLiteral {
                range,
            }),
          )
        }
        NodeKind::BooleanLiteral => {
          let value = hermes_get_BooleanLiteral_value(n);
          cvt.ast_context.alloc(
            ast::Node::BooleanLiteral(ast::BooleanLiteral {
                range,
                    value,
            }),
          )
        }
        NodeKind::StringLiteral => {
          let value = cvt_string(hermes_get_StringLiteral_value(n));
          cvt.ast_context.alloc(
            ast::Node::StringLiteral(ast::StringLiteral {
                range,
                    value,
            }),
          )
        }
        NodeKind::NumericLiteral => {
          let value = hermes_get_NumericLiteral_value(n);
          cvt.ast_context.alloc(
            ast::Node::NumericLiteral(ast::NumericLiteral {
                range,
                    value,
            }),
          )
        }
        NodeKind::RegExpLiteral => {
          let pattern = cvt_label(hermes_get_RegExpLiteral_pattern(n));
          let flags = cvt_label(hermes_get_RegExpLiteral_flags(n));
          cvt.ast_context.alloc(
            ast::Node::RegExpLiteral(ast::RegExpLiteral {
                range,
                    pattern,
                    flags,
            }),
          )
        }
        NodeKind::ThisExpression => {
          cvt.ast_context.alloc(
            ast::Node::ThisExpression(ast::ThisExpression {
                range,
            }),
          )
        }
        NodeKind::Super => {
          cvt.ast_context.alloc(
            ast::Node::Super(ast::Super {
                range,
            }),
          )
        }
        NodeKind::SequenceExpression => {
          let expressions = cvt_node_list(cvt, hermes_get_SequenceExpression_expressions(n));
          cvt.ast_context.alloc(
            ast::Node::SequenceExpression(ast::SequenceExpression {
                range,
                    expressions,
            }),
          )
        }
        NodeKind::ObjectExpression => {
          let properties = cvt_node_list(cvt, hermes_get_ObjectExpression_properties(n));
          cvt.ast_context.alloc(
            ast::Node::ObjectExpression(ast::ObjectExpression {
                range,
                    properties,
            }),
          )
        }
        NodeKind::ArrayExpression => {
          let elements = cvt_node_list(cvt, hermes_get_ArrayExpression_elements(n));
          let trailing_comma = hermes_get_ArrayExpression_trailingComma(n);
          cvt.ast_context.alloc(
            ast::Node::ArrayExpression(ast::ArrayExpression {
                range,
                    elements,
                    trailing_comma,
            }),
          )
        }
        NodeKind::SpreadElement => {
          let argument = cvt_node_ptr(cvt, hermes_get_SpreadElement_argument(n));
          cvt.ast_context.alloc(
            ast::Node::SpreadElement(ast::SpreadElement {
                range,
                    argument,
            }),
          )
        }
        NodeKind::NewExpression => {
          let callee = cvt_node_ptr(cvt, hermes_get_NewExpression_callee(n));
          let type_arguments = cvt_node_ptr_opt(cvt, hermes_get_NewExpression_typeArguments(n));
          let arguments = cvt_node_list(cvt, hermes_get_NewExpression_arguments(n));
          cvt.ast_context.alloc(
            ast::Node::NewExpression(ast::NewExpression {
                range,
                    callee,
                    type_arguments,
                    arguments,
            }),
          )
        }
        NodeKind::YieldExpression => {
          let argument = cvt_node_ptr_opt(cvt, hermes_get_YieldExpression_argument(n));
          let delegate = hermes_get_YieldExpression_delegate(n);
          cvt.ast_context.alloc(
            ast::Node::YieldExpression(ast::YieldExpression {
                range,
                    argument,
                    delegate,
            }),
          )
        }
        NodeKind::AwaitExpression => {
          let argument = cvt_node_ptr(cvt, hermes_get_AwaitExpression_argument(n));
          cvt.ast_context.alloc(
            ast::Node::AwaitExpression(ast::AwaitExpression {
                range,
                    argument,
            }),
          )
        }
        NodeKind::ImportExpression => {
          let source = cvt_node_ptr(cvt, hermes_get_ImportExpression_source(n));
          let attributes = cvt_node_ptr_opt(cvt, hermes_get_ImportExpression_attributes(n));
          cvt.ast_context.alloc(
            ast::Node::ImportExpression(ast::ImportExpression {
                range,
                    source,
                    attributes,
            }),
          )
        }
        NodeKind::CallExpression => {
          let callee = cvt_node_ptr(cvt, hermes_get_CallExpression_callee(n));
          let type_arguments = cvt_node_ptr_opt(cvt, hermes_get_CallExpression_typeArguments(n));
          let arguments = cvt_node_list(cvt, hermes_get_CallExpression_arguments(n));
          cvt.ast_context.alloc(
            ast::Node::CallExpression(ast::CallExpression {
                range,
                    callee,
                    type_arguments,
                    arguments,
            }),
          )
        }
        NodeKind::OptionalCallExpression => {
          let callee = cvt_node_ptr(cvt, hermes_get_OptionalCallExpression_callee(n));
          let type_arguments = cvt_node_ptr_opt(cvt, hermes_get_OptionalCallExpression_typeArguments(n));
          let arguments = cvt_node_list(cvt, hermes_get_OptionalCallExpression_arguments(n));
          let optional = hermes_get_OptionalCallExpression_optional(n);
          cvt.ast_context.alloc(
            ast::Node::OptionalCallExpression(ast::OptionalCallExpression {
                range,
                    callee,
                    type_arguments,
                    arguments,
                    optional,
            }),
          )
        }
        NodeKind::AssignmentExpression => {
          let operator = cvt_enum(hermes_get_AssignmentExpression_operator(n));
          let left = cvt_node_ptr(cvt, hermes_get_AssignmentExpression_left(n));
          let right = cvt_node_ptr(cvt, hermes_get_AssignmentExpression_right(n));
          cvt.ast_context.alloc(
            ast::Node::AssignmentExpression(ast::AssignmentExpression {
                range,
                    operator,
                    left,
                    right,
            }),
          )
        }
        NodeKind::UnaryExpression => {
          let operator = cvt_enum(hermes_get_UnaryExpression_operator(n));
          let argument = cvt_node_ptr(cvt, hermes_get_UnaryExpression_argument(n));
          let prefix = hermes_get_UnaryExpression_prefix(n);
          cvt.ast_context.alloc(
            ast::Node::UnaryExpression(ast::UnaryExpression {
                range,
                    operator,
                    argument,
                    prefix,
            }),
          )
        }
        NodeKind::UpdateExpression => {
          let operator = cvt_enum(hermes_get_UpdateExpression_operator(n));
          let argument = cvt_node_ptr(cvt, hermes_get_UpdateExpression_argument(n));
          let prefix = hermes_get_UpdateExpression_prefix(n);
          cvt.ast_context.alloc(
            ast::Node::UpdateExpression(ast::UpdateExpression {
                range,
                    operator,
                    argument,
                    prefix,
            }),
          )
        }
        NodeKind::MemberExpression => {
          let object = cvt_node_ptr(cvt, hermes_get_MemberExpression_object(n));
          let property = cvt_node_ptr(cvt, hermes_get_MemberExpression_property(n));
          let computed = hermes_get_MemberExpression_computed(n);
          cvt.ast_context.alloc(
            ast::Node::MemberExpression(ast::MemberExpression {
                range,
                    object,
                    property,
                    computed,
            }),
          )
        }
        NodeKind::OptionalMemberExpression => {
          let object = cvt_node_ptr(cvt, hermes_get_OptionalMemberExpression_object(n));
          let property = cvt_node_ptr(cvt, hermes_get_OptionalMemberExpression_property(n));
          let computed = hermes_get_OptionalMemberExpression_computed(n);
          let optional = hermes_get_OptionalMemberExpression_optional(n);
          cvt.ast_context.alloc(
            ast::Node::OptionalMemberExpression(ast::OptionalMemberExpression {
                range,
                    object,
                    property,
                    computed,
                    optional,
            }),
          )
        }
        NodeKind::LogicalExpression => {
          let left = cvt_node_ptr(cvt, hermes_get_LogicalExpression_left(n));
          let right = cvt_node_ptr(cvt, hermes_get_LogicalExpression_right(n));
          let operator = cvt_enum(hermes_get_LogicalExpression_operator(n));
          cvt.ast_context.alloc(
            ast::Node::LogicalExpression(ast::LogicalExpression {
                range,
                    left,
                    right,
                    operator,
            }),
          )
        }
        NodeKind::ConditionalExpression => {
          let test = cvt_node_ptr(cvt, hermes_get_ConditionalExpression_test(n));
          let alternate = cvt_node_ptr(cvt, hermes_get_ConditionalExpression_alternate(n));
          let consequent = cvt_node_ptr(cvt, hermes_get_ConditionalExpression_consequent(n));
          cvt.ast_context.alloc(
            ast::Node::ConditionalExpression(ast::ConditionalExpression {
                range,
                    test,
                    alternate,
                    consequent,
            }),
          )
        }
        NodeKind::BinaryExpression => {
          let left = cvt_node_ptr(cvt, hermes_get_BinaryExpression_left(n));
          let right = cvt_node_ptr(cvt, hermes_get_BinaryExpression_right(n));
          let operator = cvt_enum(hermes_get_BinaryExpression_operator(n));
          cvt.ast_context.alloc(
            ast::Node::BinaryExpression(ast::BinaryExpression {
                range,
                    left,
                    right,
                    operator,
            }),
          )
        }
        NodeKind::Directive => {
          let value = cvt_node_ptr(cvt, hermes_get_Directive_value(n));
          cvt.ast_context.alloc(
            ast::Node::Directive(ast::Directive {
                range,
                    value,
            }),
          )
        }
        NodeKind::DirectiveLiteral => {
          let value = cvt_string(hermes_get_DirectiveLiteral_value(n));
          cvt.ast_context.alloc(
            ast::Node::DirectiveLiteral(ast::DirectiveLiteral {
                range,
                    value,
            }),
          )
        }
        NodeKind::Identifier => {
          let name = cvt_label(hermes_get_Identifier_name(n));
          let type_annotation = cvt_node_ptr_opt(cvt, hermes_get_Identifier_typeAnnotation(n));
          let optional = hermes_get_Identifier_optional(n);
          cvt.ast_context.alloc(
            ast::Node::Identifier(ast::Identifier {
                range,
                    name,
                    type_annotation,
                    optional,
            }),
          )
        }
        NodeKind::PrivateName => {
          let id = cvt_node_ptr(cvt, hermes_get_PrivateName_id(n));
          cvt.ast_context.alloc(
            ast::Node::PrivateName(ast::PrivateName {
                range,
                    id,
            }),
          )
        }
        NodeKind::MetaProperty => {
          let meta = cvt_node_ptr(cvt, hermes_get_MetaProperty_meta(n));
          let property = cvt_node_ptr(cvt, hermes_get_MetaProperty_property(n));
          cvt.ast_context.alloc(
            ast::Node::MetaProperty(ast::MetaProperty {
                range,
                    meta,
                    property,
            }),
          )
        }
        NodeKind::SwitchCase => {
          let test = cvt_node_ptr_opt(cvt, hermes_get_SwitchCase_test(n));
          let consequent = cvt_node_list(cvt, hermes_get_SwitchCase_consequent(n));
          cvt.ast_context.alloc(
            ast::Node::SwitchCase(ast::SwitchCase {
                range,
                    test,
                    consequent,
            }),
          )
        }
        NodeKind::CatchClause => {
          let param = cvt_node_ptr_opt(cvt, hermes_get_CatchClause_param(n));
          let body = cvt_node_ptr(cvt, hermes_get_CatchClause_body(n));
          cvt.ast_context.alloc(
            ast::Node::CatchClause(ast::CatchClause {
                range,
                    param,
                    body,
            }),
          )
        }
        NodeKind::VariableDeclarator => {
          let init = cvt_node_ptr_opt(cvt, hermes_get_VariableDeclarator_init(n));
          let id = cvt_node_ptr(cvt, hermes_get_VariableDeclarator_id(n));
          cvt.ast_context.alloc(
            ast::Node::VariableDeclarator(ast::VariableDeclarator {
                range,
                    init,
                    id,
            }),
          )
        }
        NodeKind::VariableDeclaration => {
          let kind = cvt_enum(hermes_get_VariableDeclaration_kind(n));
          let declarations = cvt_node_list(cvt, hermes_get_VariableDeclaration_declarations(n));
          cvt.ast_context.alloc(
            ast::Node::VariableDeclaration(ast::VariableDeclaration {
                range,
                    kind,
                    declarations,
            }),
          )
        }
        NodeKind::TemplateLiteral => {
          let quasis = cvt_node_list(cvt, hermes_get_TemplateLiteral_quasis(n));
          let expressions = cvt_node_list(cvt, hermes_get_TemplateLiteral_expressions(n));
          cvt.ast_context.alloc(
            ast::Node::TemplateLiteral(ast::TemplateLiteral {
                range,
                    quasis,
                    expressions,
            }),
          )
        }
        NodeKind::TaggedTemplateExpression => {
          let tag = cvt_node_ptr(cvt, hermes_get_TaggedTemplateExpression_tag(n));
          let quasi = cvt_node_ptr(cvt, hermes_get_TaggedTemplateExpression_quasi(n));
          cvt.ast_context.alloc(
            ast::Node::TaggedTemplateExpression(ast::TaggedTemplateExpression {
                range,
                    tag,
                    quasi,
            }),
          )
        }
        NodeKind::TemplateElement => {
          let tail = hermes_get_TemplateElement_tail(n);
          let cooked = cvt_string_opt(hermes_get_TemplateElement_cooked(n));
          let raw = cvt_label(hermes_get_TemplateElement_raw(n));
          cvt.ast_context.alloc(
            ast::Node::TemplateElement(ast::TemplateElement {
                range,
                    tail,
                    cooked,
                    raw,
            }),
          )
        }
        NodeKind::Property => {
          let key = cvt_node_ptr(cvt, hermes_get_Property_key(n));
          let value = cvt_node_ptr(cvt, hermes_get_Property_value(n));
          let kind = cvt_enum(hermes_get_Property_kind(n));
          let computed = hermes_get_Property_computed(n);
          let method = hermes_get_Property_method(n);
          let shorthand = hermes_get_Property_shorthand(n);
          cvt.ast_context.alloc(
            ast::Node::Property(ast::Property {
                range,
                    key,
                    value,
                    kind,
                    computed,
                    method,
                    shorthand,
            }),
          )
        }
        NodeKind::ClassDeclaration => {
          let id = cvt_node_ptr_opt(cvt, hermes_get_ClassDeclaration_id(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_ClassDeclaration_typeParameters(n));
          let super_class = cvt_node_ptr_opt(cvt, hermes_get_ClassDeclaration_superClass(n));
          let super_type_parameters = cvt_node_ptr_opt(cvt, hermes_get_ClassDeclaration_superTypeParameters(n));
          let implements = cvt_node_list(cvt, hermes_get_ClassDeclaration_implements(n));
          let decorators = cvt_node_list(cvt, hermes_get_ClassDeclaration_decorators(n));
          let body = cvt_node_ptr(cvt, hermes_get_ClassDeclaration_body(n));
          cvt.ast_context.alloc(
            ast::Node::ClassDeclaration(ast::ClassDeclaration {
                range,
                    id,
                    type_parameters,
                    super_class,
                    super_type_parameters,
                    implements,
                    decorators,
                    body,
            }),
          )
        }
        NodeKind::ClassExpression => {
          let id = cvt_node_ptr_opt(cvt, hermes_get_ClassExpression_id(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_ClassExpression_typeParameters(n));
          let super_class = cvt_node_ptr_opt(cvt, hermes_get_ClassExpression_superClass(n));
          let super_type_parameters = cvt_node_ptr_opt(cvt, hermes_get_ClassExpression_superTypeParameters(n));
          let implements = cvt_node_list(cvt, hermes_get_ClassExpression_implements(n));
          let decorators = cvt_node_list(cvt, hermes_get_ClassExpression_decorators(n));
          let body = cvt_node_ptr(cvt, hermes_get_ClassExpression_body(n));
          cvt.ast_context.alloc(
            ast::Node::ClassExpression(ast::ClassExpression {
                range,
                    id,
                    type_parameters,
                    super_class,
                    super_type_parameters,
                    implements,
                    decorators,
                    body,
            }),
          )
        }
        NodeKind::ClassBody => {
          let body = cvt_node_list(cvt, hermes_get_ClassBody_body(n));
          cvt.ast_context.alloc(
            ast::Node::ClassBody(ast::ClassBody {
                range,
                    body,
            }),
          )
        }
        NodeKind::ClassProperty => {
          let key = cvt_node_ptr(cvt, hermes_get_ClassProperty_key(n));
          let value = cvt_node_ptr_opt(cvt, hermes_get_ClassProperty_value(n));
          let computed = hermes_get_ClassProperty_computed(n);
          let is_static = hermes_get_ClassProperty_static(n);
          let declare = hermes_get_ClassProperty_declare(n);
          let optional = hermes_get_ClassProperty_optional(n);
          let variance = cvt_node_ptr_opt(cvt, hermes_get_ClassProperty_variance(n));
          let type_annotation = cvt_node_ptr_opt(cvt, hermes_get_ClassProperty_typeAnnotation(n));
          cvt.ast_context.alloc(
            ast::Node::ClassProperty(ast::ClassProperty {
                range,
                    key,
                    value,
                    computed,
                    is_static,
                    declare,
                    optional,
                    variance,
                    type_annotation,
            }),
          )
        }
        NodeKind::ClassPrivateProperty => {
          let key = cvt_node_ptr(cvt, hermes_get_ClassPrivateProperty_key(n));
          let value = cvt_node_ptr_opt(cvt, hermes_get_ClassPrivateProperty_value(n));
          let is_static = hermes_get_ClassPrivateProperty_static(n);
          let declare = hermes_get_ClassPrivateProperty_declare(n);
          let optional = hermes_get_ClassPrivateProperty_optional(n);
          let variance = cvt_node_ptr_opt(cvt, hermes_get_ClassPrivateProperty_variance(n));
          let type_annotation = cvt_node_ptr_opt(cvt, hermes_get_ClassPrivateProperty_typeAnnotation(n));
          cvt.ast_context.alloc(
            ast::Node::ClassPrivateProperty(ast::ClassPrivateProperty {
                range,
                    key,
                    value,
                    is_static,
                    declare,
                    optional,
                    variance,
                    type_annotation,
            }),
          )
        }
        NodeKind::MethodDefinition => {
          let key = cvt_node_ptr(cvt, hermes_get_MethodDefinition_key(n));
          let value = cvt_node_ptr(cvt, hermes_get_MethodDefinition_value(n));
          let kind = cvt_enum(hermes_get_MethodDefinition_kind(n));
          let computed = hermes_get_MethodDefinition_computed(n);
          let is_static = hermes_get_MethodDefinition_static(n);
          cvt.ast_context.alloc(
            ast::Node::MethodDefinition(ast::MethodDefinition {
                range,
                    key,
                    value,
                    kind,
                    computed,
                    is_static,
            }),
          )
        }
        NodeKind::ImportDeclaration => {
          let specifiers = cvt_node_list(cvt, hermes_get_ImportDeclaration_specifiers(n));
          let source = cvt_node_ptr(cvt, hermes_get_ImportDeclaration_source(n));
          let attributes = cvt_node_list_opt(cvt, hermes_get_ImportDeclaration_attributes(n));
          let import_kind = cvt_enum(hermes_get_ImportDeclaration_importKind(n));
          cvt.ast_context.alloc(
            ast::Node::ImportDeclaration(ast::ImportDeclaration {
                range,
                    specifiers,
                    source,
                    attributes,
                    import_kind,
            }),
          )
        }
        NodeKind::ImportSpecifier => {
          let imported = cvt_node_ptr(cvt, hermes_get_ImportSpecifier_imported(n));
          let local = cvt_node_ptr(cvt, hermes_get_ImportSpecifier_local(n));
          let import_kind = cvt_enum(hermes_get_ImportSpecifier_importKind(n));
          cvt.ast_context.alloc(
            ast::Node::ImportSpecifier(ast::ImportSpecifier {
                range,
                    imported,
                    local,
                    import_kind,
            }),
          )
        }
        NodeKind::ImportDefaultSpecifier => {
          let local = cvt_node_ptr(cvt, hermes_get_ImportDefaultSpecifier_local(n));
          cvt.ast_context.alloc(
            ast::Node::ImportDefaultSpecifier(ast::ImportDefaultSpecifier {
                range,
                    local,
            }),
          )
        }
        NodeKind::ImportNamespaceSpecifier => {
          let local = cvt_node_ptr(cvt, hermes_get_ImportNamespaceSpecifier_local(n));
          cvt.ast_context.alloc(
            ast::Node::ImportNamespaceSpecifier(ast::ImportNamespaceSpecifier {
                range,
                    local,
            }),
          )
        }
        NodeKind::ImportAttribute => {
          let key = cvt_node_ptr(cvt, hermes_get_ImportAttribute_key(n));
          let value = cvt_node_ptr(cvt, hermes_get_ImportAttribute_value(n));
          cvt.ast_context.alloc(
            ast::Node::ImportAttribute(ast::ImportAttribute {
                range,
                    key,
                    value,
            }),
          )
        }
        NodeKind::ExportNamedDeclaration => {
          let declaration = cvt_node_ptr_opt(cvt, hermes_get_ExportNamedDeclaration_declaration(n));
          let specifiers = cvt_node_list(cvt, hermes_get_ExportNamedDeclaration_specifiers(n));
          let source = cvt_node_ptr_opt(cvt, hermes_get_ExportNamedDeclaration_source(n));
          let export_kind = cvt_enum(hermes_get_ExportNamedDeclaration_exportKind(n));
          cvt.ast_context.alloc(
            ast::Node::ExportNamedDeclaration(ast::ExportNamedDeclaration {
                range,
                    declaration,
                    specifiers,
                    source,
                    export_kind,
            }),
          )
        }
        NodeKind::ExportSpecifier => {
          let exported = cvt_node_ptr(cvt, hermes_get_ExportSpecifier_exported(n));
          let local = cvt_node_ptr(cvt, hermes_get_ExportSpecifier_local(n));
          cvt.ast_context.alloc(
            ast::Node::ExportSpecifier(ast::ExportSpecifier {
                range,
                    exported,
                    local,
            }),
          )
        }
        NodeKind::ExportNamespaceSpecifier => {
          let exported = cvt_node_ptr(cvt, hermes_get_ExportNamespaceSpecifier_exported(n));
          cvt.ast_context.alloc(
            ast::Node::ExportNamespaceSpecifier(ast::ExportNamespaceSpecifier {
                range,
                    exported,
            }),
          )
        }
        NodeKind::ExportDefaultDeclaration => {
          let declaration = cvt_node_ptr(cvt, hermes_get_ExportDefaultDeclaration_declaration(n));
          cvt.ast_context.alloc(
            ast::Node::ExportDefaultDeclaration(ast::ExportDefaultDeclaration {
                range,
                    declaration,
            }),
          )
        }
        NodeKind::ExportAllDeclaration => {
          let source = cvt_node_ptr(cvt, hermes_get_ExportAllDeclaration_source(n));
          let export_kind = cvt_enum(hermes_get_ExportAllDeclaration_exportKind(n));
          cvt.ast_context.alloc(
            ast::Node::ExportAllDeclaration(ast::ExportAllDeclaration {
                range,
                    source,
                    export_kind,
            }),
          )
        }
        NodeKind::ObjectPattern => {
          let properties = cvt_node_list(cvt, hermes_get_ObjectPattern_properties(n));
          let type_annotation = cvt_node_ptr_opt(cvt, hermes_get_ObjectPattern_typeAnnotation(n));
          cvt.ast_context.alloc(
            ast::Node::ObjectPattern(ast::ObjectPattern {
                range,
                    properties,
                    type_annotation,
            }),
          )
        }
        NodeKind::ArrayPattern => {
          let elements = cvt_node_list(cvt, hermes_get_ArrayPattern_elements(n));
          let type_annotation = cvt_node_ptr_opt(cvt, hermes_get_ArrayPattern_typeAnnotation(n));
          cvt.ast_context.alloc(
            ast::Node::ArrayPattern(ast::ArrayPattern {
                range,
                    elements,
                    type_annotation,
            }),
          )
        }
        NodeKind::RestElement => {
          let argument = cvt_node_ptr(cvt, hermes_get_RestElement_argument(n));
          cvt.ast_context.alloc(
            ast::Node::RestElement(ast::RestElement {
                range,
                    argument,
            }),
          )
        }
        NodeKind::AssignmentPattern => {
          let left = cvt_node_ptr(cvt, hermes_get_AssignmentPattern_left(n));
          let right = cvt_node_ptr(cvt, hermes_get_AssignmentPattern_right(n));
          cvt.ast_context.alloc(
            ast::Node::AssignmentPattern(ast::AssignmentPattern {
                range,
                    left,
                    right,
            }),
          )
        }
        NodeKind::JSXIdentifier => {
          let name = cvt_label(hermes_get_JSXIdentifier_name(n));
          cvt.ast_context.alloc(
            ast::Node::JSXIdentifier(ast::JSXIdentifier {
                range,
                    name,
            }),
          )
        }
        NodeKind::JSXMemberExpression => {
          let object = cvt_node_ptr(cvt, hermes_get_JSXMemberExpression_object(n));
          let property = cvt_node_ptr(cvt, hermes_get_JSXMemberExpression_property(n));
          cvt.ast_context.alloc(
            ast::Node::JSXMemberExpression(ast::JSXMemberExpression {
                range,
                    object,
                    property,
            }),
          )
        }
        NodeKind::JSXNamespacedName => {
          let namespace = cvt_node_ptr(cvt, hermes_get_JSXNamespacedName_namespace(n));
          let name = cvt_node_ptr(cvt, hermes_get_JSXNamespacedName_name(n));
          cvt.ast_context.alloc(
            ast::Node::JSXNamespacedName(ast::JSXNamespacedName {
                range,
                    namespace,
                    name,
            }),
          )
        }
        NodeKind::JSXEmptyExpression => {
          cvt.ast_context.alloc(
            ast::Node::JSXEmptyExpression(ast::JSXEmptyExpression {
                range,
            }),
          )
        }
        NodeKind::JSXExpressionContainer => {
          let expression = cvt_node_ptr(cvt, hermes_get_JSXExpressionContainer_expression(n));
          cvt.ast_context.alloc(
            ast::Node::JSXExpressionContainer(ast::JSXExpressionContainer {
                range,
                    expression,
            }),
          )
        }
        NodeKind::JSXSpreadChild => {
          let expression = cvt_node_ptr(cvt, hermes_get_JSXSpreadChild_expression(n));
          cvt.ast_context.alloc(
            ast::Node::JSXSpreadChild(ast::JSXSpreadChild {
                range,
                    expression,
            }),
          )
        }
        NodeKind::JSXOpeningElement => {
          let name = cvt_node_ptr(cvt, hermes_get_JSXOpeningElement_name(n));
          let attributes = cvt_node_list(cvt, hermes_get_JSXOpeningElement_attributes(n));
          let self_closing = hermes_get_JSXOpeningElement_selfClosing(n);
          cvt.ast_context.alloc(
            ast::Node::JSXOpeningElement(ast::JSXOpeningElement {
                range,
                    name,
                    attributes,
                    self_closing,
            }),
          )
        }
        NodeKind::JSXClosingElement => {
          let name = cvt_node_ptr(cvt, hermes_get_JSXClosingElement_name(n));
          cvt.ast_context.alloc(
            ast::Node::JSXClosingElement(ast::JSXClosingElement {
                range,
                    name,
            }),
          )
        }
        NodeKind::JSXAttribute => {
          let name = cvt_node_ptr(cvt, hermes_get_JSXAttribute_name(n));
          let value = cvt_node_ptr_opt(cvt, hermes_get_JSXAttribute_value(n));
          cvt.ast_context.alloc(
            ast::Node::JSXAttribute(ast::JSXAttribute {
                range,
                    name,
                    value,
            }),
          )
        }
        NodeKind::JSXSpreadAttribute => {
          let argument = cvt_node_ptr(cvt, hermes_get_JSXSpreadAttribute_argument(n));
          cvt.ast_context.alloc(
            ast::Node::JSXSpreadAttribute(ast::JSXSpreadAttribute {
                range,
                    argument,
            }),
          )
        }
        NodeKind::JSXText => {
          let value = cvt_string(hermes_get_JSXText_value(n));
          let raw = cvt_string(hermes_get_JSXText_raw(n));
          cvt.ast_context.alloc(
            ast::Node::JSXText(ast::JSXText {
                range,
                    value,
                    raw,
            }),
          )
        }
        NodeKind::JSXElement => {
          let opening_element = cvt_node_ptr(cvt, hermes_get_JSXElement_openingElement(n));
          let children = cvt_node_list(cvt, hermes_get_JSXElement_children(n));
          let closing_element = cvt_node_ptr_opt(cvt, hermes_get_JSXElement_closingElement(n));
          cvt.ast_context.alloc(
            ast::Node::JSXElement(ast::JSXElement {
                range,
                    opening_element,
                    children,
                    closing_element,
            }),
          )
        }
        NodeKind::JSXFragment => {
          let opening_fragment = cvt_node_ptr(cvt, hermes_get_JSXFragment_openingFragment(n));
          let children = cvt_node_list(cvt, hermes_get_JSXFragment_children(n));
          let closing_fragment = cvt_node_ptr(cvt, hermes_get_JSXFragment_closingFragment(n));
          cvt.ast_context.alloc(
            ast::Node::JSXFragment(ast::JSXFragment {
                range,
                    opening_fragment,
                    children,
                    closing_fragment,
            }),
          )
        }
        NodeKind::JSXOpeningFragment => {
          cvt.ast_context.alloc(
            ast::Node::JSXOpeningFragment(ast::JSXOpeningFragment {
                range,
            }),
          )
        }
        NodeKind::JSXClosingFragment => {
          cvt.ast_context.alloc(
            ast::Node::JSXClosingFragment(ast::JSXClosingFragment {
                range,
            }),
          )
        }
        NodeKind::ExistsTypeAnnotation => {
          cvt.ast_context.alloc(
            ast::Node::ExistsTypeAnnotation(ast::ExistsTypeAnnotation {
                range,
            }),
          )
        }
        NodeKind::EmptyTypeAnnotation => {
          cvt.ast_context.alloc(
            ast::Node::EmptyTypeAnnotation(ast::EmptyTypeAnnotation {
                range,
            }),
          )
        }
        NodeKind::StringTypeAnnotation => {
          cvt.ast_context.alloc(
            ast::Node::StringTypeAnnotation(ast::StringTypeAnnotation {
                range,
            }),
          )
        }
        NodeKind::NumberTypeAnnotation => {
          cvt.ast_context.alloc(
            ast::Node::NumberTypeAnnotation(ast::NumberTypeAnnotation {
                range,
            }),
          )
        }
        NodeKind::StringLiteralTypeAnnotation => {
          let value = cvt_string(hermes_get_StringLiteralTypeAnnotation_value(n));
          cvt.ast_context.alloc(
            ast::Node::StringLiteralTypeAnnotation(ast::StringLiteralTypeAnnotation {
                range,
                    value,
            }),
          )
        }
        NodeKind::NumberLiteralTypeAnnotation => {
          let value = hermes_get_NumberLiteralTypeAnnotation_value(n);
          let raw = cvt_label(hermes_get_NumberLiteralTypeAnnotation_raw(n));
          cvt.ast_context.alloc(
            ast::Node::NumberLiteralTypeAnnotation(ast::NumberLiteralTypeAnnotation {
                range,
                    value,
                    raw,
            }),
          )
        }
        NodeKind::BooleanTypeAnnotation => {
          cvt.ast_context.alloc(
            ast::Node::BooleanTypeAnnotation(ast::BooleanTypeAnnotation {
                range,
            }),
          )
        }
        NodeKind::BooleanLiteralTypeAnnotation => {
          let value = hermes_get_BooleanLiteralTypeAnnotation_value(n);
          let raw = cvt_label(hermes_get_BooleanLiteralTypeAnnotation_raw(n));
          cvt.ast_context.alloc(
            ast::Node::BooleanLiteralTypeAnnotation(ast::BooleanLiteralTypeAnnotation {
                range,
                    value,
                    raw,
            }),
          )
        }
        NodeKind::NullLiteralTypeAnnotation => {
          cvt.ast_context.alloc(
            ast::Node::NullLiteralTypeAnnotation(ast::NullLiteralTypeAnnotation {
                range,
            }),
          )
        }
        NodeKind::SymbolTypeAnnotation => {
          cvt.ast_context.alloc(
            ast::Node::SymbolTypeAnnotation(ast::SymbolTypeAnnotation {
                range,
            }),
          )
        }
        NodeKind::AnyTypeAnnotation => {
          cvt.ast_context.alloc(
            ast::Node::AnyTypeAnnotation(ast::AnyTypeAnnotation {
                range,
            }),
          )
        }
        NodeKind::MixedTypeAnnotation => {
          cvt.ast_context.alloc(
            ast::Node::MixedTypeAnnotation(ast::MixedTypeAnnotation {
                range,
            }),
          )
        }
        NodeKind::VoidTypeAnnotation => {
          cvt.ast_context.alloc(
            ast::Node::VoidTypeAnnotation(ast::VoidTypeAnnotation {
                range,
            }),
          )
        }
        NodeKind::FunctionTypeAnnotation => {
          let params = cvt_node_list(cvt, hermes_get_FunctionTypeAnnotation_params(n));
          let this = cvt_node_ptr_opt(cvt, hermes_get_FunctionTypeAnnotation_this(n));
          let return_type = cvt_node_ptr(cvt, hermes_get_FunctionTypeAnnotation_returnType(n));
          let rest = cvt_node_ptr_opt(cvt, hermes_get_FunctionTypeAnnotation_rest(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_FunctionTypeAnnotation_typeParameters(n));
          cvt.ast_context.alloc(
            ast::Node::FunctionTypeAnnotation(ast::FunctionTypeAnnotation {
                range,
                    params,
                    this,
                    return_type,
                    rest,
                    type_parameters,
            }),
          )
        }
        NodeKind::FunctionTypeParam => {
          let name = cvt_node_ptr_opt(cvt, hermes_get_FunctionTypeParam_name(n));
          let type_annotation = cvt_node_ptr(cvt, hermes_get_FunctionTypeParam_typeAnnotation(n));
          let optional = hermes_get_FunctionTypeParam_optional(n);
          cvt.ast_context.alloc(
            ast::Node::FunctionTypeParam(ast::FunctionTypeParam {
                range,
                    name,
                    type_annotation,
                    optional,
            }),
          )
        }
        NodeKind::NullableTypeAnnotation => {
          let type_annotation = cvt_node_ptr(cvt, hermes_get_NullableTypeAnnotation_typeAnnotation(n));
          cvt.ast_context.alloc(
            ast::Node::NullableTypeAnnotation(ast::NullableTypeAnnotation {
                range,
                    type_annotation,
            }),
          )
        }
        NodeKind::QualifiedTypeIdentifier => {
          let qualification = cvt_node_ptr(cvt, hermes_get_QualifiedTypeIdentifier_qualification(n));
          let id = cvt_node_ptr(cvt, hermes_get_QualifiedTypeIdentifier_id(n));
          cvt.ast_context.alloc(
            ast::Node::QualifiedTypeIdentifier(ast::QualifiedTypeIdentifier {
                range,
                    qualification,
                    id,
            }),
          )
        }
        NodeKind::TypeofTypeAnnotation => {
          let argument = cvt_node_ptr(cvt, hermes_get_TypeofTypeAnnotation_argument(n));
          cvt.ast_context.alloc(
            ast::Node::TypeofTypeAnnotation(ast::TypeofTypeAnnotation {
                range,
                    argument,
            }),
          )
        }
        NodeKind::TupleTypeAnnotation => {
          let types = cvt_node_list(cvt, hermes_get_TupleTypeAnnotation_types(n));
          cvt.ast_context.alloc(
            ast::Node::TupleTypeAnnotation(ast::TupleTypeAnnotation {
                range,
                    types,
            }),
          )
        }
        NodeKind::ArrayTypeAnnotation => {
          let element_type = cvt_node_ptr(cvt, hermes_get_ArrayTypeAnnotation_elementType(n));
          cvt.ast_context.alloc(
            ast::Node::ArrayTypeAnnotation(ast::ArrayTypeAnnotation {
                range,
                    element_type,
            }),
          )
        }
        NodeKind::UnionTypeAnnotation => {
          let types = cvt_node_list(cvt, hermes_get_UnionTypeAnnotation_types(n));
          cvt.ast_context.alloc(
            ast::Node::UnionTypeAnnotation(ast::UnionTypeAnnotation {
                range,
                    types,
            }),
          )
        }
        NodeKind::IntersectionTypeAnnotation => {
          let types = cvt_node_list(cvt, hermes_get_IntersectionTypeAnnotation_types(n));
          cvt.ast_context.alloc(
            ast::Node::IntersectionTypeAnnotation(ast::IntersectionTypeAnnotation {
                range,
                    types,
            }),
          )
        }
        NodeKind::GenericTypeAnnotation => {
          let id = cvt_node_ptr(cvt, hermes_get_GenericTypeAnnotation_id(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_GenericTypeAnnotation_typeParameters(n));
          cvt.ast_context.alloc(
            ast::Node::GenericTypeAnnotation(ast::GenericTypeAnnotation {
                range,
                    id,
                    type_parameters,
            }),
          )
        }
        NodeKind::IndexedAccessType => {
          let object_type = cvt_node_ptr(cvt, hermes_get_IndexedAccessType_objectType(n));
          let index_type = cvt_node_ptr(cvt, hermes_get_IndexedAccessType_indexType(n));
          cvt.ast_context.alloc(
            ast::Node::IndexedAccessType(ast::IndexedAccessType {
                range,
                    object_type,
                    index_type,
            }),
          )
        }
        NodeKind::OptionalIndexedAccessType => {
          let object_type = cvt_node_ptr(cvt, hermes_get_OptionalIndexedAccessType_objectType(n));
          let index_type = cvt_node_ptr(cvt, hermes_get_OptionalIndexedAccessType_indexType(n));
          let optional = hermes_get_OptionalIndexedAccessType_optional(n);
          cvt.ast_context.alloc(
            ast::Node::OptionalIndexedAccessType(ast::OptionalIndexedAccessType {
                range,
                    object_type,
                    index_type,
                    optional,
            }),
          )
        }
        NodeKind::InterfaceTypeAnnotation => {
          let extends = cvt_node_list(cvt, hermes_get_InterfaceTypeAnnotation_extends(n));
          let body = cvt_node_ptr_opt(cvt, hermes_get_InterfaceTypeAnnotation_body(n));
          cvt.ast_context.alloc(
            ast::Node::InterfaceTypeAnnotation(ast::InterfaceTypeAnnotation {
                range,
                    extends,
                    body,
            }),
          )
        }
        NodeKind::TypeAlias => {
          let id = cvt_node_ptr(cvt, hermes_get_TypeAlias_id(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_TypeAlias_typeParameters(n));
          let right = cvt_node_ptr(cvt, hermes_get_TypeAlias_right(n));
          cvt.ast_context.alloc(
            ast::Node::TypeAlias(ast::TypeAlias {
                range,
                    id,
                    type_parameters,
                    right,
            }),
          )
        }
        NodeKind::OpaqueType => {
          let id = cvt_node_ptr(cvt, hermes_get_OpaqueType_id(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_OpaqueType_typeParameters(n));
          let impltype = cvt_node_ptr(cvt, hermes_get_OpaqueType_impltype(n));
          let supertype = cvt_node_ptr_opt(cvt, hermes_get_OpaqueType_supertype(n));
          cvt.ast_context.alloc(
            ast::Node::OpaqueType(ast::OpaqueType {
                range,
                    id,
                    type_parameters,
                    impltype,
                    supertype,
            }),
          )
        }
        NodeKind::InterfaceDeclaration => {
          let id = cvt_node_ptr(cvt, hermes_get_InterfaceDeclaration_id(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_InterfaceDeclaration_typeParameters(n));
          let extends = cvt_node_list(cvt, hermes_get_InterfaceDeclaration_extends(n));
          let body = cvt_node_ptr(cvt, hermes_get_InterfaceDeclaration_body(n));
          cvt.ast_context.alloc(
            ast::Node::InterfaceDeclaration(ast::InterfaceDeclaration {
                range,
                    id,
                    type_parameters,
                    extends,
                    body,
            }),
          )
        }
        NodeKind::DeclareTypeAlias => {
          let id = cvt_node_ptr(cvt, hermes_get_DeclareTypeAlias_id(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_DeclareTypeAlias_typeParameters(n));
          let right = cvt_node_ptr(cvt, hermes_get_DeclareTypeAlias_right(n));
          cvt.ast_context.alloc(
            ast::Node::DeclareTypeAlias(ast::DeclareTypeAlias {
                range,
                    id,
                    type_parameters,
                    right,
            }),
          )
        }
        NodeKind::DeclareOpaqueType => {
          let id = cvt_node_ptr(cvt, hermes_get_DeclareOpaqueType_id(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_DeclareOpaqueType_typeParameters(n));
          let impltype = cvt_node_ptr_opt(cvt, hermes_get_DeclareOpaqueType_impltype(n));
          let supertype = cvt_node_ptr_opt(cvt, hermes_get_DeclareOpaqueType_supertype(n));
          cvt.ast_context.alloc(
            ast::Node::DeclareOpaqueType(ast::DeclareOpaqueType {
                range,
                    id,
                    type_parameters,
                    impltype,
                    supertype,
            }),
          )
        }
        NodeKind::DeclareInterface => {
          let id = cvt_node_ptr(cvt, hermes_get_DeclareInterface_id(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_DeclareInterface_typeParameters(n));
          let extends = cvt_node_list(cvt, hermes_get_DeclareInterface_extends(n));
          let body = cvt_node_ptr(cvt, hermes_get_DeclareInterface_body(n));
          cvt.ast_context.alloc(
            ast::Node::DeclareInterface(ast::DeclareInterface {
                range,
                    id,
                    type_parameters,
                    extends,
                    body,
            }),
          )
        }
        NodeKind::DeclareClass => {
          let id = cvt_node_ptr(cvt, hermes_get_DeclareClass_id(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_DeclareClass_typeParameters(n));
          let extends = cvt_node_list(cvt, hermes_get_DeclareClass_extends(n));
          let implements = cvt_node_list(cvt, hermes_get_DeclareClass_implements(n));
          let mixins = cvt_node_list(cvt, hermes_get_DeclareClass_mixins(n));
          let body = cvt_node_ptr(cvt, hermes_get_DeclareClass_body(n));
          cvt.ast_context.alloc(
            ast::Node::DeclareClass(ast::DeclareClass {
                range,
                    id,
                    type_parameters,
                    extends,
                    implements,
                    mixins,
                    body,
            }),
          )
        }
        NodeKind::DeclareFunction => {
          let id = cvt_node_ptr(cvt, hermes_get_DeclareFunction_id(n));
          let predicate = cvt_node_ptr_opt(cvt, hermes_get_DeclareFunction_predicate(n));
          cvt.ast_context.alloc(
            ast::Node::DeclareFunction(ast::DeclareFunction {
                range,
                    id,
                    predicate,
            }),
          )
        }
        NodeKind::DeclareVariable => {
          let id = cvt_node_ptr(cvt, hermes_get_DeclareVariable_id(n));
          cvt.ast_context.alloc(
            ast::Node::DeclareVariable(ast::DeclareVariable {
                range,
                    id,
            }),
          )
        }
        NodeKind::DeclareExportDeclaration => {
          let declaration = cvt_node_ptr_opt(cvt, hermes_get_DeclareExportDeclaration_declaration(n));
          let specifiers = cvt_node_list(cvt, hermes_get_DeclareExportDeclaration_specifiers(n));
          let source = cvt_node_ptr_opt(cvt, hermes_get_DeclareExportDeclaration_source(n));
          let default = hermes_get_DeclareExportDeclaration_default(n);
          cvt.ast_context.alloc(
            ast::Node::DeclareExportDeclaration(ast::DeclareExportDeclaration {
                range,
                    declaration,
                    specifiers,
                    source,
                    default,
            }),
          )
        }
        NodeKind::DeclareExportAllDeclaration => {
          let source = cvt_node_ptr(cvt, hermes_get_DeclareExportAllDeclaration_source(n));
          cvt.ast_context.alloc(
            ast::Node::DeclareExportAllDeclaration(ast::DeclareExportAllDeclaration {
                range,
                    source,
            }),
          )
        }
        NodeKind::DeclareModule => {
          let id = cvt_node_ptr(cvt, hermes_get_DeclareModule_id(n));
          let body = cvt_node_ptr(cvt, hermes_get_DeclareModule_body(n));
          let kind = cvt_label(hermes_get_DeclareModule_kind(n));
          cvt.ast_context.alloc(
            ast::Node::DeclareModule(ast::DeclareModule {
                range,
                    id,
                    body,
                    kind,
            }),
          )
        }
        NodeKind::DeclareModuleExports => {
          let type_annotation = cvt_node_ptr(cvt, hermes_get_DeclareModuleExports_typeAnnotation(n));
          cvt.ast_context.alloc(
            ast::Node::DeclareModuleExports(ast::DeclareModuleExports {
                range,
                    type_annotation,
            }),
          )
        }
        NodeKind::InterfaceExtends => {
          let id = cvt_node_ptr(cvt, hermes_get_InterfaceExtends_id(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_InterfaceExtends_typeParameters(n));
          cvt.ast_context.alloc(
            ast::Node::InterfaceExtends(ast::InterfaceExtends {
                range,
                    id,
                    type_parameters,
            }),
          )
        }
        NodeKind::ClassImplements => {
          let id = cvt_node_ptr(cvt, hermes_get_ClassImplements_id(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_ClassImplements_typeParameters(n));
          cvt.ast_context.alloc(
            ast::Node::ClassImplements(ast::ClassImplements {
                range,
                    id,
                    type_parameters,
            }),
          )
        }
        NodeKind::TypeAnnotation => {
          let type_annotation = cvt_node_ptr(cvt, hermes_get_TypeAnnotation_typeAnnotation(n));
          cvt.ast_context.alloc(
            ast::Node::TypeAnnotation(ast::TypeAnnotation {
                range,
                    type_annotation,
            }),
          )
        }
        NodeKind::ObjectTypeAnnotation => {
          let properties = cvt_node_list(cvt, hermes_get_ObjectTypeAnnotation_properties(n));
          let indexers = cvt_node_list(cvt, hermes_get_ObjectTypeAnnotation_indexers(n));
          let call_properties = cvt_node_list(cvt, hermes_get_ObjectTypeAnnotation_callProperties(n));
          let internal_slots = cvt_node_list(cvt, hermes_get_ObjectTypeAnnotation_internalSlots(n));
          let inexact = hermes_get_ObjectTypeAnnotation_inexact(n);
          let exact = hermes_get_ObjectTypeAnnotation_exact(n);
          cvt.ast_context.alloc(
            ast::Node::ObjectTypeAnnotation(ast::ObjectTypeAnnotation {
                range,
                    properties,
                    indexers,
                    call_properties,
                    internal_slots,
                    inexact,
                    exact,
            }),
          )
        }
        NodeKind::ObjectTypeProperty => {
          let key = cvt_node_ptr(cvt, hermes_get_ObjectTypeProperty_key(n));
          let value = cvt_node_ptr(cvt, hermes_get_ObjectTypeProperty_value(n));
          let method = hermes_get_ObjectTypeProperty_method(n);
          let optional = hermes_get_ObjectTypeProperty_optional(n);
          let is_static = hermes_get_ObjectTypeProperty_static(n);
          let proto = hermes_get_ObjectTypeProperty_proto(n);
          let variance = cvt_node_ptr_opt(cvt, hermes_get_ObjectTypeProperty_variance(n));
          let kind = cvt_label(hermes_get_ObjectTypeProperty_kind(n));
          cvt.ast_context.alloc(
            ast::Node::ObjectTypeProperty(ast::ObjectTypeProperty {
                range,
                    key,
                    value,
                    method,
                    optional,
                    is_static,
                    proto,
                    variance,
                    kind,
            }),
          )
        }
        NodeKind::ObjectTypeSpreadProperty => {
          let argument = cvt_node_ptr(cvt, hermes_get_ObjectTypeSpreadProperty_argument(n));
          cvt.ast_context.alloc(
            ast::Node::ObjectTypeSpreadProperty(ast::ObjectTypeSpreadProperty {
                range,
                    argument,
            }),
          )
        }
        NodeKind::ObjectTypeInternalSlot => {
          let id = cvt_node_ptr(cvt, hermes_get_ObjectTypeInternalSlot_id(n));
          let value = cvt_node_ptr(cvt, hermes_get_ObjectTypeInternalSlot_value(n));
          let optional = hermes_get_ObjectTypeInternalSlot_optional(n);
          let is_static = hermes_get_ObjectTypeInternalSlot_static(n);
          let method = hermes_get_ObjectTypeInternalSlot_method(n);
          cvt.ast_context.alloc(
            ast::Node::ObjectTypeInternalSlot(ast::ObjectTypeInternalSlot {
                range,
                    id,
                    value,
                    optional,
                    is_static,
                    method,
            }),
          )
        }
        NodeKind::ObjectTypeCallProperty => {
          let value = cvt_node_ptr(cvt, hermes_get_ObjectTypeCallProperty_value(n));
          let is_static = hermes_get_ObjectTypeCallProperty_static(n);
          cvt.ast_context.alloc(
            ast::Node::ObjectTypeCallProperty(ast::ObjectTypeCallProperty {
                range,
                    value,
                    is_static,
            }),
          )
        }
        NodeKind::ObjectTypeIndexer => {
          let id = cvt_node_ptr_opt(cvt, hermes_get_ObjectTypeIndexer_id(n));
          let key = cvt_node_ptr(cvt, hermes_get_ObjectTypeIndexer_key(n));
          let value = cvt_node_ptr(cvt, hermes_get_ObjectTypeIndexer_value(n));
          let is_static = hermes_get_ObjectTypeIndexer_static(n);
          let variance = cvt_node_ptr_opt(cvt, hermes_get_ObjectTypeIndexer_variance(n));
          cvt.ast_context.alloc(
            ast::Node::ObjectTypeIndexer(ast::ObjectTypeIndexer {
                range,
                    id,
                    key,
                    value,
                    is_static,
                    variance,
            }),
          )
        }
        NodeKind::Variance => {
          let kind = cvt_label(hermes_get_Variance_kind(n));
          cvt.ast_context.alloc(
            ast::Node::Variance(ast::Variance {
                range,
                    kind,
            }),
          )
        }
        NodeKind::TypeParameterDeclaration => {
          let params = cvt_node_list(cvt, hermes_get_TypeParameterDeclaration_params(n));
          cvt.ast_context.alloc(
            ast::Node::TypeParameterDeclaration(ast::TypeParameterDeclaration {
                range,
                    params,
            }),
          )
        }
        NodeKind::TypeParameter => {
          let name = cvt_label(hermes_get_TypeParameter_name(n));
          let bound = cvt_node_ptr_opt(cvt, hermes_get_TypeParameter_bound(n));
          let variance = cvt_node_ptr_opt(cvt, hermes_get_TypeParameter_variance(n));
          let default = cvt_node_ptr_opt(cvt, hermes_get_TypeParameter_default(n));
          cvt.ast_context.alloc(
            ast::Node::TypeParameter(ast::TypeParameter {
                range,
                    name,
                    bound,
                    variance,
                    default,
            }),
          )
        }
        NodeKind::TypeParameterInstantiation => {
          let params = cvt_node_list(cvt, hermes_get_TypeParameterInstantiation_params(n));
          cvt.ast_context.alloc(
            ast::Node::TypeParameterInstantiation(ast::TypeParameterInstantiation {
                range,
                    params,
            }),
          )
        }
        NodeKind::TypeCastExpression => {
          let expression = cvt_node_ptr(cvt, hermes_get_TypeCastExpression_expression(n));
          let type_annotation = cvt_node_ptr(cvt, hermes_get_TypeCastExpression_typeAnnotation(n));
          cvt.ast_context.alloc(
            ast::Node::TypeCastExpression(ast::TypeCastExpression {
                range,
                    expression,
                    type_annotation,
            }),
          )
        }
        NodeKind::InferredPredicate => {
          cvt.ast_context.alloc(
            ast::Node::InferredPredicate(ast::InferredPredicate {
                range,
            }),
          )
        }
        NodeKind::DeclaredPredicate => {
          let value = cvt_node_ptr(cvt, hermes_get_DeclaredPredicate_value(n));
          cvt.ast_context.alloc(
            ast::Node::DeclaredPredicate(ast::DeclaredPredicate {
                range,
                    value,
            }),
          )
        }
        NodeKind::EnumDeclaration => {
          let id = cvt_node_ptr(cvt, hermes_get_EnumDeclaration_id(n));
          let body = cvt_node_ptr(cvt, hermes_get_EnumDeclaration_body(n));
          cvt.ast_context.alloc(
            ast::Node::EnumDeclaration(ast::EnumDeclaration {
                range,
                    id,
                    body,
            }),
          )
        }
        NodeKind::EnumStringBody => {
          let members = cvt_node_list(cvt, hermes_get_EnumStringBody_members(n));
          let explicit_type = hermes_get_EnumStringBody_explicitType(n);
          let has_unknown_members = hermes_get_EnumStringBody_hasUnknownMembers(n);
          cvt.ast_context.alloc(
            ast::Node::EnumStringBody(ast::EnumStringBody {
                range,
                    members,
                    explicit_type,
                    has_unknown_members,
            }),
          )
        }
        NodeKind::EnumNumberBody => {
          let members = cvt_node_list(cvt, hermes_get_EnumNumberBody_members(n));
          let explicit_type = hermes_get_EnumNumberBody_explicitType(n);
          let has_unknown_members = hermes_get_EnumNumberBody_hasUnknownMembers(n);
          cvt.ast_context.alloc(
            ast::Node::EnumNumberBody(ast::EnumNumberBody {
                range,
                    members,
                    explicit_type,
                    has_unknown_members,
            }),
          )
        }
        NodeKind::EnumBooleanBody => {
          let members = cvt_node_list(cvt, hermes_get_EnumBooleanBody_members(n));
          let explicit_type = hermes_get_EnumBooleanBody_explicitType(n);
          let has_unknown_members = hermes_get_EnumBooleanBody_hasUnknownMembers(n);
          cvt.ast_context.alloc(
            ast::Node::EnumBooleanBody(ast::EnumBooleanBody {
                range,
                    members,
                    explicit_type,
                    has_unknown_members,
            }),
          )
        }
        NodeKind::EnumSymbolBody => {
          let members = cvt_node_list(cvt, hermes_get_EnumSymbolBody_members(n));
          let has_unknown_members = hermes_get_EnumSymbolBody_hasUnknownMembers(n);
          cvt.ast_context.alloc(
            ast::Node::EnumSymbolBody(ast::EnumSymbolBody {
                range,
                    members,
                    has_unknown_members,
            }),
          )
        }
        NodeKind::EnumDefaultedMember => {
          let id = cvt_node_ptr(cvt, hermes_get_EnumDefaultedMember_id(n));
          cvt.ast_context.alloc(
            ast::Node::EnumDefaultedMember(ast::EnumDefaultedMember {
                range,
                    id,
            }),
          )
        }
        NodeKind::EnumStringMember => {
          let id = cvt_node_ptr(cvt, hermes_get_EnumStringMember_id(n));
          let init = cvt_node_ptr(cvt, hermes_get_EnumStringMember_init(n));
          cvt.ast_context.alloc(
            ast::Node::EnumStringMember(ast::EnumStringMember {
                range,
                    id,
                    init,
            }),
          )
        }
        NodeKind::EnumNumberMember => {
          let id = cvt_node_ptr(cvt, hermes_get_EnumNumberMember_id(n));
          let init = cvt_node_ptr(cvt, hermes_get_EnumNumberMember_init(n));
          cvt.ast_context.alloc(
            ast::Node::EnumNumberMember(ast::EnumNumberMember {
                range,
                    id,
                    init,
            }),
          )
        }
        NodeKind::EnumBooleanMember => {
          let id = cvt_node_ptr(cvt, hermes_get_EnumBooleanMember_id(n));
          let init = cvt_node_ptr(cvt, hermes_get_EnumBooleanMember_init(n));
          cvt.ast_context.alloc(
            ast::Node::EnumBooleanMember(ast::EnumBooleanMember {
                range,
                    id,
                    init,
            }),
          )
        }
        NodeKind::TSTypeAnnotation => {
          let type_annotation = cvt_node_ptr(cvt, hermes_get_TSTypeAnnotation_typeAnnotation(n));
          cvt.ast_context.alloc(
            ast::Node::TSTypeAnnotation(ast::TSTypeAnnotation {
                range,
                    type_annotation,
            }),
          )
        }
        NodeKind::TSAnyKeyword => {
          cvt.ast_context.alloc(
            ast::Node::TSAnyKeyword(ast::TSAnyKeyword {
                range,
            }),
          )
        }
        NodeKind::TSNumberKeyword => {
          cvt.ast_context.alloc(
            ast::Node::TSNumberKeyword(ast::TSNumberKeyword {
                range,
            }),
          )
        }
        NodeKind::TSBooleanKeyword => {
          cvt.ast_context.alloc(
            ast::Node::TSBooleanKeyword(ast::TSBooleanKeyword {
                range,
            }),
          )
        }
        NodeKind::TSStringKeyword => {
          cvt.ast_context.alloc(
            ast::Node::TSStringKeyword(ast::TSStringKeyword {
                range,
            }),
          )
        }
        NodeKind::TSSymbolKeyword => {
          cvt.ast_context.alloc(
            ast::Node::TSSymbolKeyword(ast::TSSymbolKeyword {
                range,
            }),
          )
        }
        NodeKind::TSVoidKeyword => {
          cvt.ast_context.alloc(
            ast::Node::TSVoidKeyword(ast::TSVoidKeyword {
                range,
            }),
          )
        }
        NodeKind::TSThisType => {
          cvt.ast_context.alloc(
            ast::Node::TSThisType(ast::TSThisType {
                range,
            }),
          )
        }
        NodeKind::TSLiteralType => {
          let literal = cvt_node_ptr(cvt, hermes_get_TSLiteralType_literal(n));
          cvt.ast_context.alloc(
            ast::Node::TSLiteralType(ast::TSLiteralType {
                range,
                    literal,
            }),
          )
        }
        NodeKind::TSIndexedAccessType => {
          let object_type = cvt_node_ptr(cvt, hermes_get_TSIndexedAccessType_objectType(n));
          let index_type = cvt_node_ptr(cvt, hermes_get_TSIndexedAccessType_indexType(n));
          cvt.ast_context.alloc(
            ast::Node::TSIndexedAccessType(ast::TSIndexedAccessType {
                range,
                    object_type,
                    index_type,
            }),
          )
        }
        NodeKind::TSArrayType => {
          let element_type = cvt_node_ptr(cvt, hermes_get_TSArrayType_elementType(n));
          cvt.ast_context.alloc(
            ast::Node::TSArrayType(ast::TSArrayType {
                range,
                    element_type,
            }),
          )
        }
        NodeKind::TSTypeReference => {
          let type_name = cvt_node_ptr(cvt, hermes_get_TSTypeReference_typeName(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_TSTypeReference_typeParameters(n));
          cvt.ast_context.alloc(
            ast::Node::TSTypeReference(ast::TSTypeReference {
                range,
                    type_name,
                    type_parameters,
            }),
          )
        }
        NodeKind::TSQualifiedName => {
          let left = cvt_node_ptr(cvt, hermes_get_TSQualifiedName_left(n));
          let right = cvt_node_ptr_opt(cvt, hermes_get_TSQualifiedName_right(n));
          cvt.ast_context.alloc(
            ast::Node::TSQualifiedName(ast::TSQualifiedName {
                range,
                    left,
                    right,
            }),
          )
        }
        NodeKind::TSFunctionType => {
          let params = cvt_node_list(cvt, hermes_get_TSFunctionType_params(n));
          let return_type = cvt_node_ptr(cvt, hermes_get_TSFunctionType_returnType(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_TSFunctionType_typeParameters(n));
          cvt.ast_context.alloc(
            ast::Node::TSFunctionType(ast::TSFunctionType {
                range,
                    params,
                    return_type,
                    type_parameters,
            }),
          )
        }
        NodeKind::TSConstructorType => {
          let params = cvt_node_list(cvt, hermes_get_TSConstructorType_params(n));
          let return_type = cvt_node_ptr(cvt, hermes_get_TSConstructorType_returnType(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_TSConstructorType_typeParameters(n));
          cvt.ast_context.alloc(
            ast::Node::TSConstructorType(ast::TSConstructorType {
                range,
                    params,
                    return_type,
                    type_parameters,
            }),
          )
        }
        NodeKind::TSTypePredicate => {
          let parameter_name = cvt_node_ptr(cvt, hermes_get_TSTypePredicate_parameterName(n));
          let type_annotation = cvt_node_ptr(cvt, hermes_get_TSTypePredicate_typeAnnotation(n));
          cvt.ast_context.alloc(
            ast::Node::TSTypePredicate(ast::TSTypePredicate {
                range,
                    parameter_name,
                    type_annotation,
            }),
          )
        }
        NodeKind::TSTupleType => {
          let element_types = cvt_node_list(cvt, hermes_get_TSTupleType_elementTypes(n));
          cvt.ast_context.alloc(
            ast::Node::TSTupleType(ast::TSTupleType {
                range,
                    element_types,
            }),
          )
        }
        NodeKind::TSTypeAssertion => {
          let type_annotation = cvt_node_ptr(cvt, hermes_get_TSTypeAssertion_typeAnnotation(n));
          let expression = cvt_node_ptr(cvt, hermes_get_TSTypeAssertion_expression(n));
          cvt.ast_context.alloc(
            ast::Node::TSTypeAssertion(ast::TSTypeAssertion {
                range,
                    type_annotation,
                    expression,
            }),
          )
        }
        NodeKind::TSAsExpression => {
          let expression = cvt_node_ptr(cvt, hermes_get_TSAsExpression_expression(n));
          let type_annotation = cvt_node_ptr(cvt, hermes_get_TSAsExpression_typeAnnotation(n));
          cvt.ast_context.alloc(
            ast::Node::TSAsExpression(ast::TSAsExpression {
                range,
                    expression,
                    type_annotation,
            }),
          )
        }
        NodeKind::TSParameterProperty => {
          let parameter = cvt_node_ptr(cvt, hermes_get_TSParameterProperty_parameter(n));
          let accessibility = cvt_label_opt(hermes_get_TSParameterProperty_accessibility(n));
          let readonly = hermes_get_TSParameterProperty_readonly(n);
          let is_static = hermes_get_TSParameterProperty_static(n);
          let export = hermes_get_TSParameterProperty_export(n);
          cvt.ast_context.alloc(
            ast::Node::TSParameterProperty(ast::TSParameterProperty {
                range,
                    parameter,
                    accessibility,
                    readonly,
                    is_static,
                    export,
            }),
          )
        }
        NodeKind::TSTypeAliasDeclaration => {
          let id = cvt_node_ptr(cvt, hermes_get_TSTypeAliasDeclaration_id(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_TSTypeAliasDeclaration_typeParameters(n));
          let type_annotation = cvt_node_ptr(cvt, hermes_get_TSTypeAliasDeclaration_typeAnnotation(n));
          cvt.ast_context.alloc(
            ast::Node::TSTypeAliasDeclaration(ast::TSTypeAliasDeclaration {
                range,
                    id,
                    type_parameters,
                    type_annotation,
            }),
          )
        }
        NodeKind::TSInterfaceDeclaration => {
          let id = cvt_node_ptr(cvt, hermes_get_TSInterfaceDeclaration_id(n));
          let body = cvt_node_ptr(cvt, hermes_get_TSInterfaceDeclaration_body(n));
          let extends = cvt_node_list(cvt, hermes_get_TSInterfaceDeclaration_extends(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_TSInterfaceDeclaration_typeParameters(n));
          cvt.ast_context.alloc(
            ast::Node::TSInterfaceDeclaration(ast::TSInterfaceDeclaration {
                range,
                    id,
                    body,
                    extends,
                    type_parameters,
            }),
          )
        }
        NodeKind::TSInterfaceHeritage => {
          let expression = cvt_node_ptr(cvt, hermes_get_TSInterfaceHeritage_expression(n));
          let type_parameters = cvt_node_ptr_opt(cvt, hermes_get_TSInterfaceHeritage_typeParameters(n));
          cvt.ast_context.alloc(
            ast::Node::TSInterfaceHeritage(ast::TSInterfaceHeritage {
                range,
                    expression,
                    type_parameters,
            }),
          )
        }
        NodeKind::TSInterfaceBody => {
          let body = cvt_node_list(cvt, hermes_get_TSInterfaceBody_body(n));
          cvt.ast_context.alloc(
            ast::Node::TSInterfaceBody(ast::TSInterfaceBody {
                range,
                    body,
            }),
          )
        }
        NodeKind::TSEnumDeclaration => {
          let id = cvt_node_ptr(cvt, hermes_get_TSEnumDeclaration_id(n));
          let members = cvt_node_list(cvt, hermes_get_TSEnumDeclaration_members(n));
          cvt.ast_context.alloc(
            ast::Node::TSEnumDeclaration(ast::TSEnumDeclaration {
                range,
                    id,
                    members,
            }),
          )
        }
        NodeKind::TSEnumMember => {
          let id = cvt_node_ptr(cvt, hermes_get_TSEnumMember_id(n));
          let initializer = cvt_node_ptr_opt(cvt, hermes_get_TSEnumMember_initializer(n));
          cvt.ast_context.alloc(
            ast::Node::TSEnumMember(ast::TSEnumMember {
                range,
                    id,
                    initializer,
            }),
          )
        }
        NodeKind::TSModuleDeclaration => {
          let id = cvt_node_ptr(cvt, hermes_get_TSModuleDeclaration_id(n));
          let body = cvt_node_ptr(cvt, hermes_get_TSModuleDeclaration_body(n));
          cvt.ast_context.alloc(
            ast::Node::TSModuleDeclaration(ast::TSModuleDeclaration {
                range,
                    id,
                    body,
            }),
          )
        }
        NodeKind::TSModuleBlock => {
          let body = cvt_node_list(cvt, hermes_get_TSModuleBlock_body(n));
          cvt.ast_context.alloc(
            ast::Node::TSModuleBlock(ast::TSModuleBlock {
                range,
                    body,
            }),
          )
        }
        NodeKind::TSModuleMember => {
          let id = cvt_node_ptr(cvt, hermes_get_TSModuleMember_id(n));
          let initializer = cvt_node_ptr_opt(cvt, hermes_get_TSModuleMember_initializer(n));
          cvt.ast_context.alloc(
            ast::Node::TSModuleMember(ast::TSModuleMember {
                range,
                    id,
                    initializer,
            }),
          )
        }
        NodeKind::TSTypeParameterDeclaration => {
          let params = cvt_node_list(cvt, hermes_get_TSTypeParameterDeclaration_params(n));
          cvt.ast_context.alloc(
            ast::Node::TSTypeParameterDeclaration(ast::TSTypeParameterDeclaration {
                range,
                    params,
            }),
          )
        }
        NodeKind::TSTypeParameter => {
          let name = cvt_node_ptr(cvt, hermes_get_TSTypeParameter_name(n));
          let constraint = cvt_node_ptr_opt(cvt, hermes_get_TSTypeParameter_constraint(n));
          let default = cvt_node_ptr_opt(cvt, hermes_get_TSTypeParameter_default(n));
          cvt.ast_context.alloc(
            ast::Node::TSTypeParameter(ast::TSTypeParameter {
                range,
                    name,
                    constraint,
                    default,
            }),
          )
        }
        NodeKind::TSTypeParameterInstantiation => {
          let params = cvt_node_list(cvt, hermes_get_TSTypeParameterInstantiation_params(n));
          cvt.ast_context.alloc(
            ast::Node::TSTypeParameterInstantiation(ast::TSTypeParameterInstantiation {
                range,
                    params,
            }),
          )
        }
        NodeKind::TSUnionType => {
          let types = cvt_node_list(cvt, hermes_get_TSUnionType_types(n));
          cvt.ast_context.alloc(
            ast::Node::TSUnionType(ast::TSUnionType {
                range,
                    types,
            }),
          )
        }
        NodeKind::TSIntersectionType => {
          let types = cvt_node_list(cvt, hermes_get_TSIntersectionType_types(n));
          cvt.ast_context.alloc(
            ast::Node::TSIntersectionType(ast::TSIntersectionType {
                range,
                    types,
            }),
          )
        }
        NodeKind::TSTypeQuery => {
          let expr_name = cvt_node_ptr(cvt, hermes_get_TSTypeQuery_exprName(n));
          cvt.ast_context.alloc(
            ast::Node::TSTypeQuery(ast::TSTypeQuery {
                range,
                    expr_name,
            }),
          )
        }
        NodeKind::TSConditionalType => {
          let extends_type = cvt_node_ptr(cvt, hermes_get_TSConditionalType_extendsType(n));
          let check_type = cvt_node_ptr(cvt, hermes_get_TSConditionalType_checkType(n));
          let true_type = cvt_node_ptr(cvt, hermes_get_TSConditionalType_trueType(n));
          let false_t_ype = cvt_node_ptr(cvt, hermes_get_TSConditionalType_falseTYpe(n));
          cvt.ast_context.alloc(
            ast::Node::TSConditionalType(ast::TSConditionalType {
                range,
                    extends_type,
                    check_type,
                    true_type,
                    false_t_ype,
            }),
          )
        }
        NodeKind::TSTypeLiteral => {
          let members = cvt_node_list(cvt, hermes_get_TSTypeLiteral_members(n));
          cvt.ast_context.alloc(
            ast::Node::TSTypeLiteral(ast::TSTypeLiteral {
                range,
                    members,
            }),
          )
        }
        NodeKind::TSPropertySignature => {
          let key = cvt_node_ptr(cvt, hermes_get_TSPropertySignature_key(n));
          let type_annotation = cvt_node_ptr_opt(cvt, hermes_get_TSPropertySignature_typeAnnotation(n));
          let initializer = cvt_node_ptr_opt(cvt, hermes_get_TSPropertySignature_initializer(n));
          let optional = hermes_get_TSPropertySignature_optional(n);
          let computed = hermes_get_TSPropertySignature_computed(n);
          let readonly = hermes_get_TSPropertySignature_readonly(n);
          let is_static = hermes_get_TSPropertySignature_static(n);
          let export = hermes_get_TSPropertySignature_export(n);
          cvt.ast_context.alloc(
            ast::Node::TSPropertySignature(ast::TSPropertySignature {
                range,
                    key,
                    type_annotation,
                    initializer,
                    optional,
                    computed,
                    readonly,
                    is_static,
                    export,
            }),
          )
        }
        NodeKind::TSMethodSignature => {
          let key = cvt_node_ptr(cvt, hermes_get_TSMethodSignature_key(n));
          let params = cvt_node_list(cvt, hermes_get_TSMethodSignature_params(n));
          let return_type = cvt_node_ptr_opt(cvt, hermes_get_TSMethodSignature_returnType(n));
          let computed = hermes_get_TSMethodSignature_computed(n);
          cvt.ast_context.alloc(
            ast::Node::TSMethodSignature(ast::TSMethodSignature {
                range,
                    key,
                    params,
                    return_type,
                    computed,
            }),
          )
        }
        NodeKind::TSIndexSignature => {
          let parameters = cvt_node_list(cvt, hermes_get_TSIndexSignature_parameters(n));
          let type_annotation = cvt_node_ptr_opt(cvt, hermes_get_TSIndexSignature_typeAnnotation(n));
          cvt.ast_context.alloc(
            ast::Node::TSIndexSignature(ast::TSIndexSignature {
                range,
                    parameters,
                    type_annotation,
            }),
          )
        }
        NodeKind::TSCallSignatureDeclaration => {
          let params = cvt_node_list(cvt, hermes_get_TSCallSignatureDeclaration_params(n));
          let return_type = cvt_node_ptr_opt(cvt, hermes_get_TSCallSignatureDeclaration_returnType(n));
          cvt.ast_context.alloc(
            ast::Node::TSCallSignatureDeclaration(ast::TSCallSignatureDeclaration {
                range,
                    params,
                    return_type,
            }),
          )
        }
        _ => panic!("Invalid node kind")
    };

    cvt.ast_context.node_mut(res).range_mut().end = cvt.cvt_smloc(nr.source_range.end.pred());

    res}
